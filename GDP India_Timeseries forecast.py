# -*- coding: utf-8 -*-
"""GDP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o8mFccZ66kQyDy00__tqE5n_-OwBUJ7p
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf,plot_pacf
from statsmodels.tsa.arima.model import ARIMA

# Data loading

data = pd.read_csv(r'GDP_India.csv')

# Indexing

data.set_index('Year',inplace=True)

# Plotting Data Orginal

plt.figure(figsize=(10,6))
plt.plot(data)
plt.title("GDP Rate of India")
plt.xlabel("Year")
plt.ylabel("Growth Rate")
plt.show()

# Decomposing

result = seasonal_decompose(data,model='additive',period=3)
result.plot()
plt.show()

# Rolling Statitics

rol_mean=data['GDP growth (annual %)'].rolling(window=2).mean()
rol_std=data['GDP growth (annual %)'].rolling(window=2).std()

plt.figure(figsize=(10,6))
plt.plot(data,label='Orginal Data')
plt.plot(rol_mean,label='Rolling Mean')
plt.plot(rol_std,label='Rolling Std')
plt.legend()
plt.show()

# Dickey fuller

result2 = adfuller(data['GDP growth (annual %)'])
print('ADF Stati :',result2[0])
print('p_val :',result2[1])
print('Critical values')
for key,value in result2[4].items():
    print(f'{key}:{value}')
if result2[1] < 0.05:
    print("Series is stationary")

else:
    print("Series is non stationary")

# SMA

data['SMA_10'] = data['GDP growth (annual %)'].rolling(window=2).mean()

plt.figure(figsize=(10,6))
plt.plot(data,label='Orginal Data')
plt.plot(data['SMA_10'],label="simple moving average")
plt.title('Simple moving average')
plt.xlabel('Year')
plt.ylabel('value')
plt.legend()
plt.show()

# Differencing

result2 = adfuller(data['GDP growth (annual %)'])
print("p_val before log :", result2[1])

# Add a small constant to avoid taking log of zero
data['logValue'] = np.log(data['GDP growth (annual %)'] + 1e-9)
data['Diff1'] = data['logValue'].diff(1)
data['SeasDiff12'] = data['Diff1'].diff(12)

stationary_series = data['SeasDiff12'].dropna()

# Check if stationary_series is not empty before performing adfuller test
if not stationary_series.empty:
    adf_stat, p_val, *_ = adfuller(stationary_series)
    print("ADF p_val after transforms", p_val)
else:
    print("Stationary series is empty after differencing. Cannot perform adfuller test.")

# ACF & PACF

fig,axes = plt.subplots(1,2,figsize=(10,6))
plot_acf(data['GDP growth (annual %)'],lags=4,ax=axes[0])
plot_pacf(data['GDP growth (annual %)'],lags=4,ax=axes[1])
plt.show()

# ARIMA

ar_model = ARIMA(data['GDP growth (annual %)'],order=(2,0,0))
ar_result3 = ar_model.fit()
print(ar_result3.summary())

ma_model = ARIMA(data['GDP growth (annual %)'],order=(0,0,1))
ma_result3 = ma_model.fit()
print(ma_result3.summary())

# ARIMA model (using the original data with Year index)
model = ARIMA(data['GDP growth (annual %)'],order=(2,1,1))
result4=model.fit()

# Forecast
forecast=result4.forecast(steps=12)
print(forecast)

# Plotting the forecast
plt.figure(figsize=(10,6))
plt.plot(data['GDP growth (annual %)'],label='History')

# Create the date index for the forecast.
# Use the last year from the original data's index to start the forecast years.
last_year = data.index.max()
# Assuming the data is annual, create a range of years for the forecast
forecast_index = pd.RangeIndex(start=last_year + 1, stop=last_year + 1 + len(forecast), step=1)


# Plot the forecast using the generated index
plt.plot(forecast_index, forecast.values, label='Forecast',color='r')
plt.legend()
plt.show()
